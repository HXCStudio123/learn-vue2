<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      text
      <h1>{{msg}}hello{{msg}}hello</h1>
    </div>
    <!-- <scirpt src="../dist/vue.js"></scirpt> -->
    <script src="./dist/vue.js"></script>
    <script>
      const vm = new Vue({
        el: "#app",
        data: {
          msg: 'world',
          arr: [{ name: 1 }],
          obj: {
            name: "1",
            age: 2,
          },
        },
      });
      vm.obj = { test: 33 };
      // 1. 模板解析，把当前的模板解析成js，每次更新都是重新替换，（在1.0的时候没有采用虚拟DOm 因此性能极差）
      // 2. 根据解析的语法生成虚拟DOM，通过比较虚拟DOM之间的差异去做更新页面
      // 上次说错了Vue虚拟DOM其实是抄angular，react是最后添加的

      // 明确了上面的问题之后就可以知道，其实我们需要做的就是做html->js之间 的一个转换。
      // 通常做语法转换，是用的就是AST语法树,AST语法树其实就是一种抽象描述语言的树形结构，
      // 树上的每一个节点都是对当前属性的形容。我们在日常生活中用到的ES6到ES5转换就是用的AST、还有做代码压缩等等。
      // html -> ast -> js语法 -> 虚拟DOM
      // render函数 （ast -> 虚拟DOM）
      // 通过上一步拿到虚拟DOm后 可以根据虚拟DOm渲染成真实的DOM
      // 注意：此时没有添加双向绑定
      // 每次修改时可以手动触发vm._update(vm._render()) 进行页面渲染
      // 这样就会存在问题：1.每次数据变更都要手动触发 2.如果变更多个数据，那么每次都需要重新渲染DOM 因此就需要异步队列处理DOM渲染问题
      // 综上所述，在渲染的基础上，就需要添加 《双向绑定》 和 《异步更新》
      setTimeout(()=>{
        vm.msg = '--测试--'
        // vm._update(vm._render())
      }, 1000)

      // 解决问题一：在原来的基础上，添加双向绑定逻辑
      // 1. 在初始化时，将 要渲染的视图 和（当前视图中使用的数据）关联起来
      // 2. 数据更改后，通知（使用该数据的所有视图）进行重新渲染
      // 其中 数据其实就是dep（依赖），视图就是watcher（观察者）
      console.log(vm);
    </script>
  </body>
</html>
