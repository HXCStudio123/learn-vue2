<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">{{fullname}} {{fullname}} {{fullname}}</div>
    <!-- <div id="app">
      text
      <h1>{{msg}}hello{{msg}}hello</h1>
    </div> -->
    <!-- <scirpt src="../dist/vue.js"></scirpt> -->
    <script src="./dist/vue.js"></script>
    <script>
      const vm = new Vue({
        el: "#app",
        data: {
          msg: "world",
          firstName: "hou",
          lastName: "xinchao",
          arr: [{ name: 1 }],
          obj: {
            name: "1",
            age: 2,
          },
        },
        computed: {
          fullname() {
            console.log("run");
            return this.firstName + this.lastName;
          },
        },
      });
      vm.obj = { test: 33 };
      // 1. 模板解析，把当前的模板解析成js，每次更新都是重新替换，（在1.0的时候没有采用虚拟DOm 因此性能极差）
      // 2. 根据解析的语法生成虚拟DOM，通过比较虚拟DOM之间的差异去做更新页面
      // 上次说错了Vue虚拟DOM其实是抄angular，react是最后添加的

      // 明确了上面的问题之后就可以知道，其实我们需要做的就是做html->js之间 的一个转换。
      // 通常做语法转换，是用的就是AST语法树,AST语法树其实就是一种抽象描述语言的树形结构，
      // 树上的每一个节点都是对当前属性的形容。我们在日常生活中用到的ES6到ES5转换就是用的AST、还有做代码压缩等等。
      // html -> ast -> js语法 -> 虚拟DOM
      // render函数 （ast -> 虚拟DOM）
      // 通过上一步拿到虚拟DOm后 可以根据虚拟DOm渲染成真实的DOM
      // 注意：此时没有添加双向绑定
      // 每次修改时可以手动触发vm._update(vm._render()) 进行页面渲染
      // 这样就会存在问题：1.每次数据变更都要手动触发 2.如果变更多个数据，那么每次都需要重新渲染DOM 因此就需要异步队列处理DOM渲染问题
      // 综上所述，在渲染的基础上，就需要添加 《双向绑定》 和 《异步更新》
      // setTimeout(()=>{
      //   vm.msg = '--测试--'
      //   vm._update(vm._render())
      // }, 0)

      // 解决问题一：在原来的基础上，添加双向绑定逻辑
      // 1. 在初始化时，将 要渲染的视图 和（当前视图中使用的数据）关联起来
      // 2. 数据更改后，通知（使用该数据的所有视图）进行重新渲染
      // 其中 数据其实就是dep（依赖），视图就是watcher（观察者）
      // setTimeout(()=>{
      //   vm.msg = '--测试--'
      // }, 0)

      /**
       * nextTick 异步队列处理
       * 变换值之后不会立即渲染页面，渲染页面的操作是异步的
       * 但是用户用的异步函数可能不同，导致获取真实dom的顺序发生变化
       * 因此Vue内部也暴露了一个统一的nextTick方法
       *
       * */
      // vm.msg = "22"; // 变换值之后不会立即渲染页面，渲染页面的操作是异步的
      // console.log(document.getElementById("app").innerHTML);
      // vm.$nextTick(() => {
      //   console.log(document.getElementById("app").innerHTML);
      // });
      // vm.msg = "33";
      // vm.$nextTick(() => {
      //   console.log(document.getElementById("app").innerHTML);
      // });
      // vm.msg = "44";
      // vm.$nextTick(() => {
      //   console.log(document.getElementById("app").innerHTML);
      // });
      // 此时nextTick中有一个渲染和三个自定义的。
      /**
       * 当前代码节点：变更对应计算属性引用的值，页面不发生变化，因为firstname只被computed watcher监听到
       * */
      // vm.firstName = "new hou";
      // console.log('xin', vm.fullname) // 还是houxinchao 并没有变成 new houxinchao

      /**
       * 在watcher中加入dirty逻辑后，可以获取到最新内容了 new houxinchao
       * fullname虽然更新了 但是页面内容并没有更新，
       * 将计算属性watcher内的dep，加到当前的渲染watcher上，使dep属性变更时可以同步watcher视图更新
       * 此时视图值也更新了
       * */
    </script>
  </body>
</html>
